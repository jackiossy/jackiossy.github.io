<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        :root {
            --accent-color: #FF4D4D;
        }
    </style>

    
    
    
    
    
    

    
    <title>从 UIKit 到 SwiftUI：一个 iOS 开发者的“思维革命”</title>
    <meta name="description" content="——写给三年前写 Auto Layout 约束写到手抽筋的我
【短笺一｜从“摆控件”到“叙事”】
那晚我在 storyboard 里拖了第六条约束，按钮还是偏一像素。我把屏幕一锁，换成 SwiftUI 起手的三行：
VStack(spacing: 12) { TitleView(text: title) …">
    <meta name="keywords" content='blog, gokarna, hugo, iOS'>

    <meta property="og:url" content="https://blog.mose.ltd/posts/%E4%BB%8E-uikit-%E5%88%B0-swiftui%E4%B8%80%E4%B8%AA-ios-%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E6%80%9D%E7%BB%B4%E9%9D%A9%E5%91%BD/">
    <meta property="og:type" content="website">
    <meta property="og:title" content="从 UIKit 到 SwiftUI：一个 iOS 开发者的“思维革命”">
    <meta property="og:description" content="——写给三年前写 Auto Layout 约束写到手抽筋的我
【短笺一｜从“摆控件”到“叙事”】
那晚我在 storyboard 里拖了第六条约束，按钮还是偏一像素。我把屏幕一锁，换成 SwiftUI 起手的三行：
VStack(spacing: 12) { TitleView(text: title) …">
    <meta property="og:image" content="https://blog.mose.ltd/images/avatar.jpg">
    <meta property="og:image:secure_url" content="https://blog.mose.ltd/images/avatar.jpg">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="从 UIKit 到 SwiftUI：一个 iOS 开发者的“思维革命”">
    <meta name="twitter:description" content="——写给三年前写 Auto Layout 约束写到手抽筋的我
【短笺一｜从“摆控件”到“叙事”】
那晚我在 storyboard 里拖了第六条约束，按钮还是偏一像素。我把屏幕一锁，换成 SwiftUI 起手的三行：
VStack(spacing: 12) { TitleView(text: title) …">
    <meta property="twitter:domain" content="https://blog.mose.ltd/posts/%E4%BB%8E-uikit-%E5%88%B0-swiftui%E4%B8%80%E4%B8%AA-ios-%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E6%80%9D%E7%BB%B4%E9%9D%A9%E5%91%BD/">
    <meta property="twitter:url" content="https://blog.mose.ltd/posts/%E4%BB%8E-uikit-%E5%88%B0-swiftui%E4%B8%80%E4%B8%AA-ios-%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E6%80%9D%E7%BB%B4%E9%9D%A9%E5%91%BD/">
    <meta name="twitter:image" content="https://blog.mose.ltd/images/avatar.jpg">

    
    <link rel="canonical" href="https://blog.mose.ltd/posts/%E4%BB%8E-uikit-%E5%88%B0-swiftui%E4%B8%80%E4%B8%AA-ios-%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E6%80%9D%E7%BB%B4%E9%9D%A9%E5%91%BD/">

    
    <link rel="stylesheet" type="text/css" href="/css/normalize.min.css" media="print">

    
    <link rel="stylesheet" type="text/css" href="/css/main.min.css">

    
    <link id="dark-theme" rel="stylesheet" href="/css/dark.min.css">

    
    <script src="/js/bundle.min.3eb19cb61dde9e37b9522867f3e024aeb68e26ab8e03252e46e365abcb19acf7.js" integrity="sha256-PrGcth3enje5Uihn8&#43;AkrraOJquOAyUuRuNlq8sZrPc="></script>

    
    
    <link rel='stylesheet' href='/css/site-tweak.css'>
    
</head>
<body>
        <script>
            
            setThemeByUserPref();
        </script><header class="header">
    <nav class="header-nav">

        
        <div class="avatar">
            <a href="https://blog.mose.ltd/">
                <img src='/images/avatar.jpg' alt="avatar">
            </a>
        </div>
        

        <div class="nav-title">
            <a class="nav-brand" href="https://blog.mose.ltd/">Biney&#39;s blog</a>
        </div>

        <div class="nav-links">
            
            <div class="nav-link">
                <a href="https://blog.mose.ltd/posts/" aria-label="posts" > Posts </a>
            </div>
            
            <div class="nav-link">
                <a href="https://blog.mose.ltd/tags/" aria-label="tags" > Tags </a>
            </div>
            
            <div class="nav-link">
                <a href="https://github.com" aria-label="github" ><span data-feather='github'></span>  </a>
            </div>
            

            <span class="nav-icons-divider"></span>
            <div class="nav-link dark-theme-toggle">
                <span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
                <a aria-hidden="true" role="switch">
                    <span class="theme-toggle-icon" data-feather="moon"></span>
                </a>
            </div>

            <div class="nav-link" id="hamburger-menu-toggle">
                <span class="sr-only hamburger-menu-toggle-screen-reader-target">menu</span>
                <a aria-checked="false" aria-labelledby="hamburger-menu-toggle" id="hamburger-menu-toggle-target" role="switch">
                    <span data-feather="menu"></span>
                </a>
            </div>

            
            <ul class="nav-hamburger-list visibility-hidden">
                
                <li class="nav-item">
                    <a href="https://blog.mose.ltd/posts/" > Posts </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://blog.mose.ltd/tags/" > Tags </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://github.com" ><span data-feather='github'></span>  </a>
                </li>
                
                <li class="nav-item dark-theme-toggle">
                    <span class="sr-only dark-theme-toggle-screen-reader-target">theme</span>
                    <a role="switch">
                        <span class="theme-toggle-icon" data-feather="moon"></span>
                    </a>
                </li>
            </ul>

        </div>
    </nav>
</header>
<main id="content">
    <div class="post container">
    <div class="post-header-section">
        <h1>从 UIKit 到 SwiftUI：一个 iOS 开发者的“思维革命”</h1>

        

        
	
	
	
	
        

	

	

	
          <small role="doc-subtitle"></small>
	

	
          <p class="post-date">July 21, 2020
           
          </p>
	

        <ul class="post-tags">
          
           
             <li class="post-tag"><a href="https://blog.mose.ltd/tags/ios">iOS</a></li>
           
         
        </ul>
    </div>

    <div class="post-content">
        <p>——写给三年前写 Auto Layout 约束写到手抽筋的我</p>
<p>【短笺一｜从“摆控件”到“叙事”】</p>
<p>那晚我在 storyboard 里拖了第六条约束，按钮还是偏一像素。我把屏幕一锁，换成 SwiftUI 起手的三行：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span>VStack(spacing: <span style="color:#bd93f9">12</span>) {
</span></span><span style="display:flex;"><span>    TitleView(text: title)
</span></span><span style="display:flex;"><span>    Toggle(<span style="color:#f1fa8c">&#34;提醒我&#34;</span>, isOn: $isOn)
</span></span><span style="display:flex;"><span>    PrimaryButton(<span style="color:#f1fa8c">&#34;保存&#34;</span>, action: save)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>.padding(.horizontal, <span style="color:#bd93f9">16</span>)
</span></span></code></pre></div><p>UIKit 的工作像在摆家具：先放沙发，再推茶几，手里拿着卷尺；SwiftUI 像写分镜：镜头一、镜头二、镜头三，<strong>布局来自层次</strong>。真正的转折不是“写法更少”，而是<strong>把“界面==状态的函数”这件事当真</strong>：</p>
<p>UI = f(state)</p>
<ul>
<li>
<p>你把“按下保存键 → 置灰按钮 → 显示 HUD → 跳转下一页”的一堆 imperative 操作，换成了<strong>状态流</strong>：</p>
<p>enum ScreenState { idle, saving, saved }</p>
<p>视图只描述<strong>各状态的样子</strong>，<strong>过渡</strong>交给 SwiftUI 的 diff 和动画系统。</p>
</li>
<li>
<p>你第一次发现，删掉一半的“隐藏/显示”布尔开关，界面反而更稳。</p>
</li>
</ul>
<p><strong>给过去的你</strong>：别先问“这个控件在哪儿”，先问“这个状态有哪些形态”。形态写对了，控件自己会排好队。</p>
<p>【短笺二｜生命周期不再是“回调清单”】</p>
<p>UIKit 的脑图里有 viewDidLoad / viewWillAppear / viewDidAppear / &hellip;。SwiftUI 里，这张清单被撕碎，换成了三个钩子：</p>
<ul>
<li>onAppear：<strong>第一次渲染或再次进入视图</strong>时触发（注意：List 里的 cell 也会反复 appear）。</li>
<li>task：<strong>与视图绑定</strong>的异步任务；当视图消失时自动取消。</li>
<li>onChange(of:)：状态观察器，告诉你“<strong>变化发生了</strong>，你要不要跟一下动作”。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">struct</span> <span style="color:#50fa7b">DetailScreen</span>: View {
</span></span><span style="display:flex;"><span>    @State <span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">var</span> <span style="color:#8be9fd;font-style:italic">model</span>: Model?
</span></span><span style="display:flex;"><span>    @State <span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">var</span> <span style="color:#8be9fd;font-style:italic">isSaving</span> = <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> <span style="color:#8be9fd;font-style:italic">body</span>: some View {
</span></span><span style="display:flex;"><span>        content
</span></span><span style="display:flex;"><span>        .task { model = <span style="color:#ff79c6">try</span>? await api.fetch() }
</span></span><span style="display:flex;"><span>        .onChange(of: isSaving) { saving <span style="color:#ff79c6">in</span>
</span></span><span style="display:flex;"><span>            <span style="color:#ff79c6">if</span> saving { Analytics.log(<span style="color:#f1fa8c">&#34;begin_save&#34;</span>) }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>你不再“记着”何时解绑通知、何时取消网络请求；<strong>视图的可见性=任务的生命</strong>。</li>
<li>你第一次把“防内存泄漏”的 checklist 扔进了垃圾桶一半。</li>
</ul>
<p><strong>给过去的你</strong>：把副作用丢进 task，把监听丢进 onChange，把一次性的初始化丢进 onAppear。剩下的交给系统回收。</p>
<p>【短笺三｜布局：从 Auto Layout 的“力学”到 Stack 的“文法”】</p>
<p>Auto Layout 是“力平衡学”：约束求解器在解联立方程；SwiftUI 是“语法树”：VStack/HStack/ZStack 先定了<strong>句法</strong>，对齐和优先级再调<strong>语义</strong>。</p>
<p>三条我常用的“句法”记忆法：</p>
<ol>
<li><strong>“先骨架，后装饰”</strong>：先堆 Stack，后上 .padding/.background/.overlay。</li>
<li><strong>“让谁长，就给谁权”</strong>：Spacer() 是生长点，LayoutPriority 像优先生长权。</li>
<li><strong>“几何别太早知道”</strong>：GeometryReader 是最后手段，别拿它当万能 rAF（容易把父子布局搞反）。</li>
</ol>
<p>常见坑两个：</p>
<ul>
<li>GeometryReader 把孩子拉成无限大：外包一层 VStack { child } 或者加 fixedSize()，别让它吞掉所有空间。</li>
<li>List 的 ForEach 乱跳：<strong>id 不稳定</strong>导致 diff 误判，务必提供<strong>稳定主键</strong>。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span>ForEach(items, id: \.id) { row <span style="color:#ff79c6">in</span>
</span></span><span style="display:flex;"><span>    RowView(row)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// 千万不要 id: \.self（除非 self 是稳定的值类型主键）</span>
</span></span></code></pre></div><p><strong>给过去的你</strong>：Auto Layout 是“求解”，SwiftUI 是“表达”。表达清楚，求解自然发生。</p>
<p>【短笺四｜导航：从 push/pop 到“路径”】</p>
<p>过去我在 UINavigationController 上 push/pop；现在我给 NavigationStack 一个<strong>路径数组</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">struct</span> <span style="color:#50fa7b">AppNav</span>: View {
</span></span><span style="display:flex;"><span>    @State <span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">var</span> <span style="color:#8be9fd;font-style:italic">path</span>: [Route] = []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> <span style="color:#8be9fd;font-style:italic">body</span>: some View {
</span></span><span style="display:flex;"><span>        NavigationStack(path: $path) {
</span></span><span style="display:flex;"><span>            List(items) { item <span style="color:#ff79c6">in</span>
</span></span><span style="display:flex;"><span>                NavigationLink(value: Route.detail(item.id)) {
</span></span><span style="display:flex;"><span>                    Text(item.title)
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            .navigationDestination(<span style="color:#ff79c6">for</span>: Route.<span style="color:#ff79c6">self</span>) { route <span style="color:#ff79c6">in</span>
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">switch</span> route {
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">case</span> .detail(<span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#8be9fd;font-style:italic">id</span>): DetailScreen(id: id)
</span></span><span style="display:flex;"><span>                <span style="color:#ff79c6">case</span> .editor(<span style="color:#8be9fd;font-style:italic">let</span> <span style="color:#8be9fd;font-style:italic">id</span>): EditorScreen(id: id)
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>Deep Link = 直接改 path；</li>
<li>返回上一级 = path.removeLast()；</li>
<li>回到根 = path.removeAll()。</li>
</ul>
<p>SwiftUI 的导航不是命令式的“去那里”，而是<strong>声明现在在哪儿</strong>。</p>
<p><strong>踩坑备忘</strong>：</p>
<ul>
<li>在 iOS 16 的早期版本里，NavigationStack 与 sheet/alert 叠加时，dismiss 顺序可能乱。我的做法是：<strong>把所有呈现状态集中到一个</strong> <strong>PresentationState</strong>，用 enum 表示哪种浮层在场，避免多个布尔开关互相打架。</li>
</ul>
<p>【短笺五｜状态源：@State、@Binding、@ObservedObject、@EnvironmentObject——别混】</p>
<p>我给自己画过一张小地图：</p>
<ul>
<li>@State：<strong>视图内部的真源头</strong>（值类型）；</li>
<li>@Binding：<strong>把源头的一根“水管”借给子视图</strong>；</li>
<li>@ObservedObject：<strong>外部对象的观察</strong>（一次性订阅）；</li>
<li>@EnvironmentObject：<strong>全局供给站</strong>（跨层级注入）。</li>
</ul>
<p>错误的做法：到处塞 @EnvironmentObject，结果视图哪里都能改全局状态，调试像找幽灵。</p>
<p>正确的做法：<strong>单一数据流</strong>，能局部就局部，顶层才注入环境。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-Swift" data-lang="Swift"><span style="display:flex;"><span><span style="color:#ff79c6">final</span> <span style="color:#8be9fd;font-style:italic">class</span> <span style="color:#50fa7b">Session</span>: ObservableObject {
</span></span><span style="display:flex;"><span>    @Published <span style="color:#8be9fd;font-style:italic">var</span> <span style="color:#8be9fd;font-style:italic">user</span>: User?
</span></span><span style="display:flex;"><span>    @Published <span style="color:#8be9fd;font-style:italic">var</span> <span style="color:#8be9fd;font-style:italic">premium</span>: <span style="color:#8be9fd;font-style:italic">Bool</span> = <span style="color:#ff79c6">false</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>@main
</span></span><span style="display:flex;"><span><span style="color:#8be9fd;font-style:italic">struct</span> <span style="color:#50fa7b">AppMain</span>: App {
</span></span><span style="display:flex;"><span>    @StateObject <span style="color:#8be9fd;font-style:italic">private</span> <span style="color:#8be9fd;font-style:italic">var</span> <span style="color:#8be9fd;font-style:italic">session</span> = Session()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8be9fd;font-style:italic">var</span> <span style="color:#8be9fd;font-style:italic">body</span>: some Scene {
</span></span><span style="display:flex;"><span>        WindowGroup {
</span></span><span style="display:flex;"><span>            RootView()
</span></span><span style="display:flex;"><span>                .environmentObject(session) <span style="color:#6272a4">// 只注入一次</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>给过去的你</strong>：任何能 @State 解决的，不要上 ObservableObject；任何能传 @Binding 的，不要上 EnvironmentObject。</p>
<p>【短笺六｜动画：不是“加个 options”，而是“状态过渡”】</p>
<p>UIKit 的动画像“事务”：UIView.animate(withDuration:&hellip;) { // 改属性 }；SwiftUI 的动画像“声明”：<strong>这个状态的变化应该被动画化</strong>。</p>
<p>两种常见写法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#6272a4">// 方式 A：在状态改变时包裹</span>
</span></span><span style="display:flex;"><span>withAnimation(.spring(response: <span style="color:#bd93f9">0.3</span>, dampingFraction: <span style="color:#bd93f9">0.8</span>)) {
</span></span><span style="display:flex;"><span>    isExpanded.toggle()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#6272a4">// 方式 B：让某个值的变化总是带动画</span>
</span></span><span style="display:flex;"><span>Text(value.description)
</span></span><span style="display:flex;"><span>    .animation(.easeInOut, value: value)
</span></span></code></pre></div><ul>
<li>用 .matchedGeometryEffect 做跨视图过渡时，<strong>id 必须稳定</strong>；</li>
<li>复杂序列动画别硬顶在一处，用 phase 枚举把阶段拆开，状态驱动顺序更稳。</li>
</ul>
<p>【短笺七｜性能与“误会”】</p>
<p>SwiftUI 性能差？多半是<strong>身份误会</strong>和<strong>重建过度</strong>：</p>
<ul>
<li><strong>误会一</strong>：把大模型塞进 @State，每次变动都触发全量 diff。解法：拆粒度，或把大对象放进 ObservableObject 的小 @Published。</li>
<li><strong>误会二</strong>：body 里做重活（日期格式化、图片解码）。解法：搬到 ViewModel 或用 @MainActor + 缓存。</li>
<li><strong>误会三</strong>：ForEach 没稳定 id，List 频繁重用导致滚动丢焦点。</li>
<li><strong>误会四</strong>：在 onAppear 写单例初始化，cell 往返时反复执行。加一个 once 标记或搬到更高层。</li>
</ul>
<p><strong>诊断工具箱</strong>：</p>
<ul>
<li>Instruments 里的 <strong>SwiftUI</strong> 模板 + <strong>Time Profiler</strong>；</li>
<li>Xcode → Debug View Hierarchy 看 diff；</li>
<li>Transactions 插件可视化动画事务；</li>
<li>OSLog + Logger 给关键状态变化打点（不要 print 洪水）。</li>
</ul>
<p>【短笺八｜桥接：不是叛逃，是请老伙计来帮忙】</p>
<p>SwiftUI 不会让你当场造轮子。真遇到“UIKit 更合适”的地方，拉一座桥：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-objective-c" data-lang="objective-c"><span style="display:flex;"><span><span style="color:#ff79c6">struct</span> <span style="color:#8be9fd;font-style:italic">BlurView</span>: UIViewRepresentable {
</span></span><span style="display:flex;"><span>    func makeUIView(<span style="color:#8be9fd;font-style:italic">context</span>: Context) <span style="color:#ff79c6">-&gt;</span> UIVisualEffectView {
</span></span><span style="display:flex;"><span>        UIVisualEffectView(<span style="color:#8be9fd;font-style:italic">effect</span>: UIBlurEffect(<span style="color:#8be9fd;font-style:italic">style</span>: .systemMaterial))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    func updateUIView(_ <span style="color:#8be9fd;font-style:italic">uiView</span>: UIVisualEffectView, <span style="color:#8be9fd;font-style:italic">context</span>: Context) { }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>或把一个复杂的 UIViewController 收进来：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-objective-c" data-lang="objective-c"><span style="display:flex;"><span><span style="color:#ff79c6">struct</span> <span style="color:#8be9fd;font-style:italic">ScannerSheet</span>: UIViewControllerRepresentable {
</span></span><span style="display:flex;"><span>    func makeUIViewController(<span style="color:#8be9fd;font-style:italic">context</span>: Context) <span style="color:#ff79c6">-&gt;</span> ScannerVC { ScannerVC() }
</span></span><span style="display:flex;"><span>    func updateUIViewController(_ <span style="color:#8be9fd;font-style:italic">vc</span>: ScannerVC, <span style="color:#8be9fd;font-style:italic">context</span>: Context) { }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>要诀</strong>：桥接层<strong>只做桥接</strong>，不要把业务逻辑塞进 Representable；让 SwiftUI 仍然<strong>持有状态的源头</strong>。</p>
<p>【尾注｜我给自己的三条铁律】</p>
<ol>
<li><strong>视图是结果，不是过程</strong>：别在视图里讲故事，用状态让故事自己发生。</li>
<li><strong>一个事实只存一处</strong>：任何需要“同步两份”的状态，早晚出 bug。</li>
<li><strong>可撤销优先</strong>：重构前先把测试和日志补齐；动画、导航、全局状态的改动都要能回退。</li>
</ol>
<p>——</p>
<p>后来我回看那堆 Auto Layout 代码，心里并没有不耐烦。它们像旧城里的巷子，拐来拐去，却有味道。SwiftUI 像新修的环线，一圈绕下来，清楚利落。</p>
<p>真正的革命不是“把巷子全拆了”，而是<strong>学会什么时候走巷子，什么时候上环线</strong>。当你第一次把“界面==状态的函数”放在脑子最前面，SwiftUI 这条路就不再陌生。你会发现，手上写的，已经不是控件，而是场景。</p>

        
    </div>

    <div class="prev-next">
        
    </div>

    
    
    
</div>



    

        </main><footer class="footer">
    
    

    

    

        
            
        

        

        
        

        

    

    
        <span>&copy; 2020 Biney</span>
    

    <span>
        Made with &#10084;&#65039; using <a target="_blank" href="https://github.com/gokarna-theme/gokarna-hugo">Gokarna</a>
    </span>
</footer>
</body>
</html>
