<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>IOS on Biney&#39;s blog</title>
    <link>https://blog.mose.ltd/tags/ios/</link>
    <description>Recent content in IOS on Biney&#39;s blog</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Thu, 15 May 2025 14:33:56 +0800</lastBuildDate>
    <atom:link href="https://blog.mose.ltd/tags/ios/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>不背成语｜把 Core Data 搜索提快 70% 的门诊病历</title>
      <link>https://blog.mose.ltd/posts/%E4%B8%8D%E8%83%8C%E6%88%90%E8%AF%AD%E6%8A%8A-core-data-%E6%90%9C%E7%B4%A2%E6%8F%90%E5%BF%AB-70-%E7%9A%84%E9%97%A8%E8%AF%8A%E7%97%85%E5%8E%86/</link>
      <pubDate>Thu, 15 May 2025 14:33:56 +0800</pubDate>
      <guid>https://blog.mose.ltd/posts/%E4%B8%8D%E8%83%8C%E6%88%90%E8%AF%AD%E6%8A%8A-core-data-%E6%90%9C%E7%B4%A2%E6%8F%90%E5%BF%AB-70-%E7%9A%84%E9%97%A8%E8%AF%8A%E7%97%85%E5%8E%86/</guid>
      <description>&lt;p&gt;&lt;strong&gt;主诉&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;有用户留言：“搜索像憋着气，一下快一下慢。”我盯着输入法候选框发了会儿呆，决定把这口气顺过来。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;既往史&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;这不是云检索。我在首启时通过 &lt;strong&gt;HTTPS 拉全量&lt;/strong&gt;（上千条高频成语），&lt;strong&gt;落到 Core Data（SQLite 后端）&lt;/strong&gt;；之后每天拉&lt;strong&gt;增量更新&lt;/strong&gt;。搜索完全本地，离线也能用。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;初诊先摸脉再下刀&#34;&gt;&lt;strong&gt;初诊：先摸脉，再下刀&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;那晚我没改一行代码，只开了 &lt;strong&gt;Instruments（Core Data Fetches + Time Profiler）&lt;/strong&gt; 和 &lt;strong&gt;OSLog signpost&lt;/strong&gt;。连续敲“f”“fe”“fen”… 记录了 100 次样本（iPhone 15）：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;构建谓词：约 8 ms&lt;/li&gt;&#xA;&lt;li&gt;fetch：&lt;strong&gt;120–180 ms&lt;/strong&gt;（抖动明显）&lt;/li&gt;&#xA;&lt;li&gt;cell 绑定：约 35 ms&lt;/li&gt;&#xA;&lt;li&gt;端到端：&lt;strong&gt;170–220 ms/次&lt;/strong&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;几千条数据不该这样抖。问题不是量级，是查询形态。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;诊断几处暗伤&#34;&gt;&lt;strong&gt;诊断：几处“暗伤”&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;谓词用的是三连 &lt;strong&gt;CONTAINS&lt;/strong&gt;（汉字/拼音/首字母），在 SQLite 上基本等价全表扫；&lt;/li&gt;&#xA;&lt;li&gt;列表首屏只显示“成语+释义前缀”，却把整条对象都解包；&lt;/li&gt;&#xA;&lt;li&gt;排序按 hanzi 的默认规则，既不友好也难走索引；&lt;/li&gt;&#xA;&lt;li&gt;每次键入都在&lt;strong&gt;主队列 context&lt;/strong&gt; 上同步 fetch，UI 与 IO 抢同一口气；&lt;/li&gt;&#xA;&lt;li&gt;增量更新时只改了业务字段，忘了重算搜索相关的“衍生字段”，让老数据“口音”没改掉。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;处置五步手术步步能回退&#34;&gt;&lt;strong&gt;处置：五步手术，步步能回退&lt;/strong&gt;&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;① 重铸检索字段：把“包含”变成“可索引的前缀”&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;落地时为每条记录生成一个&lt;strong&gt;归一化 searchKey&lt;/strong&gt;：小写、去标点、空格分词，拼接“汉字 + 全拼 + 首字母”。&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;“风马牛不相及”&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;→ &lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;风马牛不相及 fengmaniu buxiangji fmn bxj&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;谓词从 CONTAINS 换成 &lt;strong&gt;LIKE 前缀&lt;/strong&gt;（能吃索引）：&lt;/p&gt;</description>
    </item>
    <item>
      <title>从 UIKit 到 SwiftUI：一个 iOS 开发者的“思维革命”</title>
      <link>https://blog.mose.ltd/posts/%E4%BB%8E-uikit-%E5%88%B0-swiftui%E4%B8%80%E4%B8%AA-ios-%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E6%80%9D%E7%BB%B4%E9%9D%A9%E5%91%BD/</link>
      <pubDate>Tue, 21 Jul 2020 14:33:56 +0800</pubDate>
      <guid>https://blog.mose.ltd/posts/%E4%BB%8E-uikit-%E5%88%B0-swiftui%E4%B8%80%E4%B8%AA-ios-%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E6%80%9D%E7%BB%B4%E9%9D%A9%E5%91%BD/</guid>
      <description>&lt;p&gt;——写给三年前写 Auto Layout 约束写到手抽筋的我&lt;/p&gt;&#xA;&lt;p&gt;【短笺一｜从“摆控件”到“叙事”】&lt;/p&gt;&#xA;&lt;p&gt;那晚我在 storyboard 里拖了第六条约束，按钮还是偏一像素。我把屏幕一锁，换成 SwiftUI 起手的三行：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-Swift&#34; data-lang=&#34;Swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;VStack(spacing: &lt;span style=&#34;color:#bd93f9&#34;&gt;12&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    TitleView(text: title)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Toggle(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;提醒我&amp;#34;&lt;/span&gt;, isOn: $isOn)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    PrimaryButton(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;保存&amp;#34;&lt;/span&gt;, action: save)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;.padding(.horizontal, &lt;span style=&#34;color:#bd93f9&#34;&gt;16&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;UIKit 的工作像在摆家具：先放沙发，再推茶几，手里拿着卷尺；SwiftUI 像写分镜：镜头一、镜头二、镜头三，&lt;strong&gt;布局来自层次&lt;/strong&gt;。真正的转折不是“写法更少”，而是&lt;strong&gt;把“界面==状态的函数”这件事当真&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;p&gt;UI = f(state)&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;你把“按下保存键 → 置灰按钮 → 显示 HUD → 跳转下一页”的一堆 imperative 操作，换成了&lt;strong&gt;状态流&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;p&gt;enum ScreenState { idle, saving, saved }&lt;/p&gt;&#xA;&lt;p&gt;视图只描述&lt;strong&gt;各状态的样子&lt;/strong&gt;，&lt;strong&gt;过渡&lt;/strong&gt;交给 SwiftUI 的 diff 和动画系统。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;你第一次发现，删掉一半的“隐藏/显示”布尔开关，界面反而更稳。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;给过去的你&lt;/strong&gt;：别先问“这个控件在哪儿”，先问“这个状态有哪些形态”。形态写对了，控件自己会排好队。&lt;/p&gt;&#xA;&lt;p&gt;【短笺二｜生命周期不再是“回调清单”】&lt;/p&gt;&#xA;&lt;p&gt;UIKit 的脑图里有 viewDidLoad / viewWillAppear / viewDidAppear / &amp;hellip;。SwiftUI 里，这张清单被撕碎，换成了三个钩子：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;onAppear：&lt;strong&gt;第一次渲染或再次进入视图&lt;/strong&gt;时触发（注意：List 里的 cell 也会反复 appear）。&lt;/li&gt;&#xA;&lt;li&gt;task：&lt;strong&gt;与视图绑定&lt;/strong&gt;的异步任务；当视图消失时自动取消。&lt;/li&gt;&#xA;&lt;li&gt;onChange(of:)：状态观察器，告诉你“&lt;strong&gt;变化发生了&lt;/strong&gt;，你要不要跟一下动作”。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#50fa7b&#34;&gt;DetailScreen&lt;/span&gt;: View {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    @State &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;model&lt;/span&gt;: Model?&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    @State &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;isSaving&lt;/span&gt; = &lt;span style=&#34;color:#ff79c6&#34;&gt;false&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#8be9fd;font-style:italic&#34;&gt;body&lt;/span&gt;: some View {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        content&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .task { model = &lt;span style=&#34;color:#ff79c6&#34;&gt;try&lt;/span&gt;? await api.fetch() }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .onChange(of: isSaving) { saving &lt;span style=&#34;color:#ff79c6&#34;&gt;in&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#ff79c6&#34;&gt;if&lt;/span&gt; saving { Analytics.log(&lt;span style=&#34;color:#f1fa8c&#34;&gt;&amp;#34;begin_save&amp;#34;&lt;/span&gt;) }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;你不再“记着”何时解绑通知、何时取消网络请求；&lt;strong&gt;视图的可见性=任务的生命&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;你第一次把“防内存泄漏”的 checklist 扔进了垃圾桶一半。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;给过去的你&lt;/strong&gt;：把副作用丢进 task，把监听丢进 onChange，把一次性的初始化丢进 onAppear。剩下的交给系统回收。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
